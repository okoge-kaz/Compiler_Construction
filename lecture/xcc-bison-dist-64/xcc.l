 /* XCC: Experimental C-subset compiler.
    Copyright (c) 2002-2016, gondow@cs.titech.ac.jp, All rights reserved.
    $Id: xcc.l,v 1.1 2016/05/19 04:25:26 gondow Exp gondow $ */ 
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "xcc.h"
#include "xcc.tab.h" /* generated by bison with '-d' option */
int  lineno = 1;     /* line number being currently processed */

/* for string_init () and string_add_char () */
enum { MAX_STR_LEN = 1024 }; /* includes the terminating null character */
char str_buf [MAX_STR_LEN];
static int  str_index;

static void string_init (void);
static void string_add_char (char c);
%}
%option nounput
%x comment string
%%
    /* white spaces */
[ \t\r]                 /* ignore white spaces */
"\n"                    { lineno++; }

    /* keywords */
char	    	    	{ return CHAR;     }
else	    	    	{ return ELSE;     }
goto                    { return GOTO;     }
if    	      	      	{ return IF;       }
int    	       	        { return INT;      }
long    	       	{ return LONG;     }
return	      	      	{ return RETURN;   }
void	    	    	{ return VOID;     }
while	     	     	{ return WHILE;    }

    /* two or more character operators and separaters
    (in xcc.y, these are referred to as literal string tokens ) */
"=="	    	    	{ return EQ;       }
"&&"	    	    	{ return AND;      }
"||"	    	    	{ return OR;       }

    /* one-character operators and separaters */
";"                     { return ';';      }
":"                     { return ':';      }
"{"                  	{ return '{';      }
"}"                     { return '}';      }
","                     { return ',';      }
"="                     { return '=';      }
"("                     { return '(';      }
")"                     { return ')';      }
"&"                     { return '&';      }
"!"                     { return '!';      }
"-"                     { return '-';      }
"+"                     { return '+';      }
"*"                     { return '*';      }
"/"                     { return '/';      }
"<"                     { return '<';      }

    /* identifiers */
[a-zA-Z_][a-zA-Z0-9_]*  { return IDENTIFIER; }

    /* integer literals (decimal only, no suffix) */
0|[1-9][0-9]*           { return INTEGER_CONSTANT; }

    /* character literals */
'\\n'|'[^\\']'          { return CHARACTER_CONSTANT; }

    /* string literals */
    /* start of string literal */
\"    	                { BEGIN(string); string_init (); }
    /* escape sequences */
<string>\\n             { string_add_char ('\\'); string_add_char ('n'); }
    /* end of string literal */
<string>\"    	        {
                            BEGIN(INITIAL);
                            string_add_char ('\0');
                            return STRING;
                        }
    /* the other characters */
<string>.    	        string_add_char (yytext[0]);

    /* comments (this way is easy to read, but not efficient) */
"/*"	    	    	BEGIN(comment);
<comment>"*/" 	    	BEGIN(INITIAL);
<comment>\n	   	lineno++; /* skipping any comments */
<comment>.    	      	;         /* skipping any comments */

    /* the other characters */
.    	     	        yyerror ("unknown character"); /* bad characters */
%%
static void
string_init (void)
{
    str_index = 0;
}

static void
string_add_char (char c)
{
    if (str_index >= MAX_STR_LEN)
    	yyerror ("max string length exceeded");
    str_buf [str_index++] = c;
}

#ifdef LEX_MAIN
int
yyerror (char *mesg)
{
    fprintf (stderr, "error: %s\n", mesg);
    exit (1);
}

int
main (void)
{
    int token;
    while (token = yylex ()) {
    	printf ("token = %d, lexeme = %s\n", token, yytext);
	if (token == STRING)
	    printf ("\tstring = %s\n", str_buf);
    }
}
#endif
